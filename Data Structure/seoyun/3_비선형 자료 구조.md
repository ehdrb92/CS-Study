# 비선형 자료 구조
비선형 자료 구조: 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조.

## 그래프
그래프: 정점과 간선으로 이루어진 자료 구조

### 정점과 간선
**어떠한 곳에서 어떠한 곳으로 무언가를 통해 간다**고 했을 때 '**어떠한 곳**'은 **정점(vertex)** 이 되고 **무언가**'는 **간선(edge)** 이 된다.  
![image](https://user-images.githubusercontent.com/91110192/201508851-cf6881a0-2399-4c49-a6c8-cb755d3e0403.png)  
  
![image](https://user-images.githubusercontent.com/91110192/201508899-3177a39d-b135-469f-84fa-a00d8e88c99e.png)

- outdegree: 정점으로 나가는 간선은 해당 정점의 outdegree (e.g. 정점 2의 outdegree는 한 개)
- indegree: 들어오는 간서을 해당 정점의 indegree (e.g. 정점 2의 indegree는 세 개)
- 가중치: 정점에서 정점까지 가는데 드는 비용

## 트리
- 그래프 중 하나 -> 정점과 간선으로 이루어짐.
- 트리 구조로 배열된 일종의 계층적 데이터의 집합
- 트리로 이루어진 집합을 '숲'이라고 함.
- 루트 노드, 내부 노드, 리프 노드 등으로 구성
   - 루트 노드: 가장 위에 있는 노드
   - 내부 노드: 자식 노드가 있는 노드
   - 리프 노드: 자식 노드가 없는 노드
- 부모, 자식 계층 구조를 가짐
- 간선 수 = 노드 수 - 1

#### 트리의 높이와 레벨
![image](https://user-images.githubusercontent.com/91110192/201509198-b8f561c6-581a-4ded-bc82-7109c032d782.png)
  
- 깊이: 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리
- 높이: 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리
- 레벨: 보통 깊이와 같은 의미. A 노드는 0레벨이라고 하고 B, C는 1레벨, D, E, F, G 노드는 2레벨이라고 함.
- 서브트리: 트리 내의 하위 집합 즉, 트리 내에 있는 부분 집합

### 이진 트리
이진 트리: 자식의 노드 수가 두 개 이하인 트리  
![image](https://user-images.githubusercontent.com/91110192/201509277-82a17373-2e03-4591-a479-1b88398f62ad.png)

- 정이진 트리(full binary tree): 자식 노드가 0 또는 두 개인 이진 트리
- 완전 이진 트리(complete binary tree): 왼쪽에서부터 채워져 있는 이진 트리
- 변질 이진 트리(degenerate binary tree): 자식 노드가 하나밖에 없는 이진 트리
- 포화 이진 트리(perfect binary tree): 모든 노드가 꽉 차 있는 이진 트리
- 균형 이진 트리(balanced binary tree): 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리. map, set을 구성하는 레드 블랙 트리는 균형 이진 트리 중 하나.  

### 이진 탐색 트리(Binary Search Tree)
이진 탐색 트리(BST): 노드의 오른쪽 하위 트리에는 '노드 값보다 큰 값'이 있는 노드만 포함되고, 왼쪽 하위 트리에는 '노드 값보다 작은 값'이 들어있는 트리  
  
보통 요소를 찾을 때 이진 탐색 트리의 경우 O(logn)이 걸리지만, 최악의 경우 O(n)이 걸린다.  
![image](https://user-images.githubusercontent.com/91110192/201509428-18ba6ca8-3884-4f08-ae11-2a4fe49d4f25.png)

### AVL 트리(Adelson-Velsky and Landis tree)
AVL 트리: 앞서 설명한 최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리. 두 자식 서브트리의 높이는 항상 최대 1만큼 차이 난다는 특징이 있다.  
탐색, 삽입, 삭제 모두 시간 복잡도가 **O(logn)** 이다.

### 레드 블랙 트리
레드 블랙 트리: 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)이다.  
각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중 트리가 균형을 유지하도록 하는 데 사용된다.  
  
  ![image](https://user-images.githubusercontent.com/91110192/201509698-e20dab99-bc3d-43c8-93f4-fc7721f9255a.png)

    
참고로 "**모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다**" 등의 규칙을 기반으로 균형을 잡는 트리이다.

## 힙
힙: 완전 이진 트리 기반의 자료 구조. 최소힙과 최대힙 두 가지가 있고 해당 힙에 따라 특정한 특징을 지킨 트리를 말함.
- 최대힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 한다. 또한, 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 한다.
- 최소힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최솟값이어야 한다.  또한, 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 한다.

![image](https://user-images.githubusercontent.com/91110192/201509799-4e1a4a8e-f345-48f3-9abf-3026f8f8c34f.png)

## 우선순위 큐
우선순위 큐(우선순위 대기열): 대기열에서 우선순위가 높은 요소가 우선 순위가 낮은 요소보다 먼저 제공되는 자료 구조로 힙을 기반으로 구현됨.  

## 맵
맵(map): 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조. 레드 블랙 트리 자료 구조를 기반으로 형성되며 해시 테이블을 구현할 때 쓰임.
- 정렬을 보장하지 않는 unordered_map
- 정렬을 보장하는 map

## 셋
셋(set): 특정 순서에 따라 고유한 요소를 저장하는 컨테이너로, 중복되는 요소가 없는 자료구조.

## 해시 테이블
해시 테이블: 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블.  
삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간 복잡도를 가지며 unordered_map으로 구현함.  
![image](https://user-images.githubusercontent.com/91110192/201509898-5b89dc48-6615-42d5-ae3a-db33a2d6e3fd.png)

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다. 해시 테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문이다. 해시 테이블은 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다. 여기서 실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 한다.  
예를 들어 우리가 (Key, Value)가 ("John Smith", "521-1234")인 데이터를 크기가 16인 해시 테이블에 저장한다고 하자. 그러면 먼저 index = hash_function("John Smith") % 16 연산을 통해 index 값을 계산한다. 그리고 array[index] = "521-1234" 로 전화번호를 저장하게 된다.  
이러한 해싱 구조로 데이터를 저장하면 Key값으로 데이터를 찾을 때 해시 함수를 1번만 수행하면 되므로 매우 빠르게 데이터를 저장/삭제/조회할 수 있다. 


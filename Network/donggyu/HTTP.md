* HTTP/1.0

    HTTP/1.0은 한 연결당 하나의 요청을 처리하도록 설계되었다. 서버로 부터 파일을 가져올 때마다 TCP의 3-way handshake를 해야하기 때문에 RTT가 증가하는 단점이 존재한다.

    + RTT 증가 해결책

        대표적인 해결책으로 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩이 있다.

        이미지 스플리팅은 여러 개의 이미지를 합쳐진 하나의 이미지로 받고 background-image의 position을 이용하여 이미지를 표기하는 방법이다. 

        코드 압축은 코드를 압축하여 개행 문자, 빈칸을 없애서 코드의 크기를 최소화하는 방법이다.

        이미지 Base64 인코딩은 이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법이다. 이 방법을 사용하면 이미지 파일에 대해 서버에 HTTP 요청을 할 필요가 없어진다.

* HTTP/1.1

    HTTP/1.0과 다르게 데이터를 전송할 때마다 TCP 연결을 해야할 필요없이 keep-alive 옵션으로 한 번의 연결로 여러 번의 송수신이 가능하다. HTTP/1.0일 때에도 해당 옵션이 존재하였지만 표준화되지 않았고, 1.1부터 표준화 되었다고 한다.
    
    하지만 한번에 다수의 리소스가 포함된 문서를 처리하기 때문에 대기시간에 길어진다는 점이 있다. 이러한 현상 중 HOL Blocking이 있다. 이는 네트워크에서 같은 큐안에 있는 패킷이 앞선 패킷의 처리과정이 느려지면서 다른 패킷의 처리 속도에 영향을 미치는 성능 저하 현상을 말한다.

    HTTP/1.1의 헤더에는 쿠키 등 많은 메타데이터가 들어 있고 압축되지 않아 무겁다.

* HTTP/2

    멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜이다.

    멀티플렉싱이란 여러 개의 스트림을 사용하여 송수신하는 것이다. 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡히 동작할 수 있다. 병렬적인 스트림들을 통해 데이터를 서빙한다. 또한, 스트림 내의 데이터들은 쪼개져 있다. 애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 송수신한 이후 다시 조립하며 데이터를 주고받는다.

    헤더 압축은 허프만 코딩 압축 알고리즘을 이용하여 HPACK 압축 형식을 가진다. 허프만 코딩은 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용하여 표현하고, 빈도가 낮은 정보는 비투 수를 많이 사용하여 표현해서 전체 데이터 표현에 필요한 비트양을 줄이는 원리이다.

    서버 푸시는 클라이언트의 요청이 있기 전 리소스를 클라이언트에게 푸시하는 것이다. html에는 보통 css, js가 함께 포함된다. 그래서 클라이언트가 요청하기 전에 필요한 css, js를 먼저 주는 것이다.

* HTTPS

    HTTP/2는 HTTPS 위에서 동작한다. HTTP의 응용 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청을 말한다. 이를 통해 통신을 암호화 한다.

    SSL/TLS는 전송 계층에서 보안을 제공하는 프로토콜이다. 클라이언트와 서버가 통신할 때 제 3자가 메시지를 도청하거나 변조하지 못하도록 한다. 보안 세션을 기반으로 데이터를 암호화하며 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용된다.

    보안 세션이란 보안이 시작되고 끝나는 동안 유지되는 세션을 말하고, SSL/TLS는 handshake를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보를 공유한다.

* HTTP/3

    이전의 HTTP와 다르게 TCP 기반이 아닌 UDP 기반의 QUIC이라는 계층 위에서 동작한다. 멀티플렉싱의 장점을 가지고 있으며 초기 연결 설정 시 지연 시간 감소라는 장점이 있다.

    QUIC는 TCP를 사용하지 않기에 3-way handshake를 하지 않는다. 그래서 초기 연결 설정 시 1-RTT만 소요한다.